name: Generate Mods & Create Releases

on:
  push:
    branches:
      - master
  workflow_dispatch:

jobs:
  detect-changes:
    name: Detect Changed Mods
    runs-on: ubuntu-latest
    outputs:
      changed_mods: ${{ steps.detect.outputs.changed_mods }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Detect changed mods
        id: detect
        run: |
          # Get all mods from mods/ directory
          MODS=$(ls -d mods/BikininjaPosters* 2>/dev/null | xargs -n1 basename | sort)
          
          if [ -z "$MODS" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "changed_mods=[]" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          CHANGED_MODS='[]'
          HAS_CHANGES=false
          
          # Check git diff to find changed mods
          for mod in $MODS; do
            MOD_DIR="mods/$mod"
            # Check if this mod dir has changes since last tag
            if git diff --quiet HEAD~1 HEAD -- "$MOD_DIR" input/ 2>/dev/null; then
              # No changes in this mod
              continue
            else
              HAS_CHANGES=true
              # Add to changed mods list
              CHANGED_MODS=$(echo "$CHANGED_MODS" | jq --arg mod "$mod" '. += [$mod]')
            fi
          done
          
          # If no specific changes detected, build all mods
          if [ "$HAS_CHANGES" = false ]; then
            CHANGED_MODS=$(echo "$MODS" | jq -R 'split("\n") | map(select(. != ""))')
            HAS_CHANGES=true
          fi
          
          echo "changed_mods=$(echo "$CHANGED_MODS" | jq -c .)" >> $GITHUB_OUTPUT
          echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
          echo "Changed mods: $(echo "$CHANGED_MODS" | jq .)"

  generate-mods:
    name: Generate Mods
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Generate mods
        run: |
          python scripts/generate_mods.py \
            --input ./input \
            --output ./mods \
            --build ./build
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: mod-archives
          path: build/*.zip
          retention-days: 30

  create-releases:
    name: Create GitHub Release for ${{ matrix.mod }}
    runs-on: ubuntu-latest
    needs: [detect-changes, generate-mods]
    if: needs.detect-changes.outputs.has_changes == 'true'
    strategy:
      matrix:
        mod: ${{ fromJson(needs.detect-changes.outputs.changed_mods) }}
      max-parallel: 1
    
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: mod-archives
          path: ./build
      
      - name: Read version from versions.json
        id: version
        run: |
          MOD="${{ matrix.mod }}"
          VERSION=$(python -c "import json; v=json.load(open('mods/versions.json')); print(v.get('versions', {}).get('$MOD', 'v1.0.0'))")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=${MOD}-${VERSION}" >> $GITHUB_OUTPUT
          echo "Detected version: $VERSION"
      
      - name: Update versions.json if needed
        run: |
          MOD="${{ matrix.mod }}"
          CURRENT_VERSION="${{ steps.version.outputs.version }}"
          
          # Parse current version
          MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1 | sed 's/v//')
          MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)
          
          # Increment patch
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          
          # Update versions.json
          python -c "
          import json
          with open('mods/versions.json', 'r') as f:
              data = json.load(f)
          data['versions']['$MOD'] = '$NEW_VERSION'
          with open('mods/versions.json', 'w') as f:
              json.dump(data, f, indent=2)
          print(f'Updated $MOD version to $NEW_VERSION')
          "
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_ENV
          echo "new_tag_name=${MOD}-${NEW_VERSION}" >> $GITHUB_ENV
      
      - name: Create git tag
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git tag -a "${{ env.new_tag_name }}" -m "Release ${{ matrix.mod }} ${{ env.new_version }}"
          git push origin "${{ env.new_tag_name }}"
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.new_tag_name }}
          name: "${{ matrix.mod }} ${{ env.new_version }}"
          body: |
            # ${{ matrix.mod }} ${{ env.new_version }}
            
            Generated mod archive for Thunderstore publishing.
            
            **Archive:** ${{ matrix.mod }}-${{ env.new_version }}.zip
            
            This release was automatically generated by CI/CD workflow.
          files: |
            build/${{ matrix.mod }}-*.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Commit version update
        run: |
          git add mods/versions.json
          git commit -m "chore: bump ${{ matrix.mod }} to ${{ env.new_version }}"
          git push origin master
        continue-on-error: true
