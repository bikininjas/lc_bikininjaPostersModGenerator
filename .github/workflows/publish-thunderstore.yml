name: Publish to Thunderstore

on:
  release:
    types: [published]

jobs:
  extract-mod-name:
    name: Extract Mod Name from Release
    runs-on: ubuntu-latest
    outputs:
      mod_name: ${{ steps.extract.outputs.mod_name }}
      version: ${{ steps.extract.outputs.version }}
    
    steps:
      - name: Extract mod name and version
        id: extract
        run: |
          # Extract from tag name (format: BikininjaPostersXX-vX.X.X)
          TAG="${{ github.event.release.tag_name }}"
          MOD_NAME=$(echo "$TAG" | sed 's/-v.*//')
          VERSION=$(echo "$TAG" | sed 's/.*-//')
          
          echo "mod_name=$MOD_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted: MOD_NAME=$MOD_NAME, VERSION=$VERSION"

  validate-release:
    name: Validate Release Assets
    runs-on: ubuntu-latest
    needs: extract-mod-name
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Verify mod structure exists
        run: |
          MOD="${{ needs.extract-mod-name.outputs.mod_name }}"
          if [ ! -d "mods/$MOD" ]; then
            echo "❌ Mod directory not found: mods/$MOD"
            exit 1
          fi
          if [ ! -f "mods/$MOD/BepInEx/plugins/Bikininja*$MOD/CustomPosters/posters"* ]; then
            echo "❌ Poster files not found in mod structure"
            exit 1
          fi
          echo "✅ Mod structure validated: $MOD"
      
      - name: Check release has ZIP asset
        run: |
          ASSETS="${{ join(github.event.release.assets.*.name, ' ') }}"
          echo "Release assets: $ASSETS"
          if [[ ! "$ASSETS" =~ \.zip$ ]]; then
            echo "❌ No ZIP file found in release assets"
            exit 1
          fi
          echo "✅ ZIP asset found"

  publish-thunderstore:
    name: Publish ${{ needs.extract-mod-name.outputs.mod_name }} to Thunderstore
    runs-on: ubuntu-latest
    needs: [extract-mod-name, validate-release]
    if: success()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download release asset
        run: |
          MOD="${{ needs.extract-mod-name.outputs.mod_name }}"
          VERSION="${{ needs.extract-mod-name.outputs.version }}"
          
          # Download the ZIP file from release
          ASSET_URL="${{ github.event.release.assets[0].browser_download_url }}"
          if [ -z "$ASSET_URL" ]; then
            echo "❌ Could not find asset download URL"
            exit 1
          fi
          
          curl -L -o "${MOD}-${VERSION}.zip" "$ASSET_URL"
          
          if [ ! -f "${MOD}-${VERSION}.zip" ]; then
            echo "❌ Failed to download ZIP file"
            exit 1
          fi
          
          echo "✅ Downloaded: ${MOD}-${VERSION}.zip"
          ls -lh "${MOD}-${VERSION}.zip"
      
      - name: Publish to Thunderstore
        run: |
          MOD="${{ needs.extract-mod-name.outputs.mod_name }}"
          VERSION="${{ needs.extract-mod-name.outputs.version }}"
          ZIP_FILE="${MOD}-${VERSION}.zip"
          
          echo "Publishing $MOD to Thunderstore..."
          
          # Use official Thunderstore action
          # The action will use THUNDERSTORE_SVC_API_KEY secret
          python -m pip install requests --quiet
          
          python << 'EOF'
          import requests
          import os
          import sys
          
          MOD_NAME = os.environ['MOD']
          VERSION = os.environ['VERSION']
          ZIP_FILE = os.environ['ZIP_FILE']
          API_KEY = os.environ['THUNDERSTORE_API_KEY']
          
          # Read ZIP file
          with open(ZIP_FILE, 'rb') as f:
              zip_content = f.read()
          
          # Prepare upload
          url = "https://thunderstore.io/api/experimental/frontend/packages/create-version/"
          headers = {
              "Authorization": f"Bearer {API_KEY}",
          }
          
          files = {
              "file": (ZIP_FILE, zip_content, "application/zip"),
          }
          
          data = {
              "namespace": "Bikininjas",
              "name": MOD_NAME,
          }
          
          print(f"Uploading {MOD_NAME} v{VERSION} to Thunderstore...")
          response = requests.post(url, files=files, data=data, headers=headers)
          
          if response.status_code in [200, 201]:
              print(f"✅ Successfully published {MOD_NAME} v{VERSION} to Thunderstore")
              print(f"Response: {response.json()}")
          else:
              print(f"❌ Failed to publish to Thunderstore")
              print(f"Status: {response.status_code}")
              print(f"Error: {response.text}")
              sys.exit(1)
          EOF
        env:
          MOD: ${{ needs.extract-mod-name.outputs.mod_name }}
          VERSION: ${{ needs.extract-mod-name.outputs.version }}
          ZIP_FILE: ${{ needs.extract-mod-name.outputs.mod_name }}-${{ needs.extract-mod-name.outputs.version }}.zip
          THUNDERSTORE_API_KEY: ${{ secrets.THUNDERSTORE_SVC_API_KEY }}
      
      - name: Verify Thunderstore upload
        run: |
          MOD="${{ needs.extract-mod-name.outputs.mod_name }}"
          VERSION="${{ needs.extract-mod-name.outputs.version }}"
          
          echo "Verifying upload on Thunderstore..."
          sleep 5  # Give Thunderstore time to process
          
          python << 'EOF'
          import requests
          import os
          
          MOD_NAME = os.environ['MOD']
          
          # Check if mod exists on Thunderstore
          url = f"https://thunderstore.io/api/v1/package/Bikininjas/{MOD_NAME}/"
          response = requests.get(url)
          
          if response.status_code == 200:
              pkg_info = response.json()
              print(f"✅ Mod successfully published to Thunderstore")
              print(f"Latest version: {pkg_info.get('latest', {}).get('version_number', 'Unknown')}")
          else:
              print(f"⚠️  Could not verify mod on Thunderstore (might still be processing)")
              print(f"Status: {response.status_code}")
          EOF
        env:
          MOD: ${{ needs.extract-mod-name.outputs.mod_name }}
